From c8dc4235614292020f82a031545d66c000b455f9 Mon Sep 17 00:00:00 2001
From: "Darrick J. Wong" <darrick.wong@oracle.com>
Date: Wed, 25 Jan 2017 20:02:43 -0600
Subject: [PATCH] xfs_db: fix the 'source' command when passed as a -c option

The 'source' command is supposed to read commands out of a file and
execute them.  This works great when done from an interactive command
line, but it doesn't work at all when invoked from the command line
because we never actually do anything with the opened file.

So don't load stdin into the input stack when we're only executing
command line options, and use that to decide if source_f is executing
from the command line so that we can actually run the input loop.  We'll
use this for the per-field fuzzing xfstests.

Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
Reviewed-by: Eric Sandeen <sandeen@redhat.com>
Signed-off-by: Eric Sandeen <sandeen@sandeen.net>
---
 db/init.c  |  2 +-
 db/input.c | 43 +++++++++++++++++++++++++++++++++----------
 2 files changed, 34 insertions(+), 11 deletions(-)

Index: xfsprogs-4.5.0/db/init.c
===================================================================
--- xfsprogs-4.5.0.orig/db/init.c
+++ xfsprogs-4.5.0/db/init.c
@@ -192,7 +192,6 @@ main(
 	char	**v;
 	int	start_iocur_sp;
 
-	pushfile(stdin);
 	init(argc, argv);
 	start_iocur_sp = iocur_sp;
 
@@ -207,6 +206,7 @@ main(
 		goto close_devices;
 	}
 
+	pushfile(stdin);
 	while (!done) {
 		if ((input = fetchline()) == NULL)
 			break;
Index: xfsprogs-4.5.0/db/input.c
===================================================================
--- xfsprogs-4.5.0.orig/db/input.c
+++ xfsprogs-4.5.0/db/input.c
@@ -156,7 +156,7 @@ fetchline_internal(void)
 
 	rval = NULL;
 	for (rlen = iscont = 0; ; ) {
-		if (inputstacksize == 1) {
+		if (curinput == stdin) {
 			if (iscont)
 				dbprintf("... ");
 			else
@@ -181,18 +181,24 @@ fetchline_internal(void)
 		}
 		if (ferror(curinput) || feof(curinput) ||
 		    (len = strlen(buf)) == 0) {
-			popfile();
-			if (curinput == NULL) {
+			/*
+			 * No more input at this inputstack level; pop
+			 * our fd off and return so that a lower
+			 * level fetchline can handle us.  If this was
+			 * an interactive session, print a newline
+			 * because ^D doesn't emit one.
+			 */
+			if (curinput == stdin)
 				dbprintf("\n");
-				return NULL;
-			}
+
+			popfile();
 			iscont = 0;
 			rlen = 0;
 			if (rval) {
 				xfree(rval);
 				rval = NULL;
 			}
-			continue;
+			return NULL;
 		}
 		if (inputstacksize == 1)
 			logprintf("%s", buf);
@@ -225,7 +231,9 @@ fetchline(void)
 
 	if (inputstacksize == 1) {
 		line = readline(get_prompt());
-		if (line && *line) {
+		if (!line)
+			dbprintf("\n");
+		else if (line && *line) {
 			add_history(line);
 			logprintf("%s", line);
 		}
@@ -314,12 +322,27 @@ source_f(
 	char	**argv)
 {
 	FILE	*f;
+	int	c, done = 0;
+	char	*input;
+	char	**v;
 
 	f = fopen(argv[1], "r");
-	if (f == NULL)
+	if (f == NULL) {
 		dbprintf(_("can't open %s\n"), argv[0]);
-	else
-		pushfile(f);
+		return 0;
+	}
+
+	/* Run the sourced commands now. */
+	pushfile(f);
+	while (!done) {
+		if ((input = fetchline_internal()) == NULL)
+			break;
+		v = breakline(input, &c);
+		if (c)
+			done = command(c, v);
+		doneline(input, v);
+	}
+
 	return 0;
 }
 
