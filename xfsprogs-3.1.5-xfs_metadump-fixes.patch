diff --git a/db/metadump.c b/db/metadump.c
index ef6e571..f757623 100644
--- a/db/metadump.c
+++ b/db/metadump.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007 Silicon Graphics, Inc.
+ * Copyright (c) 2007, 2011 SGI
  * All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
@@ -29,6 +29,14 @@
 
 #define DEFAULT_MAX_EXT_SIZE	1000
 
+/*
+ * It's possible that multiple files in a directory (or attributes
+ * in a file) produce the same obfuscated name.  If that happens, we
+ * try to create another one.  After several rounds of this though,
+ * we just give up and leave the original name as-is.
+ */
+#define	DUP_MAX		5	/* Max duplicates before we give up */
+
 /* copy all metadata structures to/from a file */
 
 static int	metadump_f(int argc, char **argv);
@@ -329,39 +337,70 @@ copy_free_cnt_btree(
 
 /* filename and extended attribute obfuscation routines */
 
-typedef struct name_ent {
+struct name_ent {
 	struct name_ent		*next;
 	xfs_dahash_t		hash;
-	int	  	    	namelen;
-	uchar_t    	    	name[1];
-} name_ent_t;
+	int			namelen;
+	uchar_t			name[1];
+};
 
 #define NAME_TABLE_SIZE		4096
 
-static name_ent_t 		**nametable;
-
-static int
-create_nametable(void)
-{
-	nametable = calloc(NAME_TABLE_SIZE, sizeof(name_ent_t));
-	return nametable != NULL;
-}
+static struct name_ent		*nametable[NAME_TABLE_SIZE];
 
 static void
-clear_nametable(void)
+nametable_clear(void)
 {
-	int			i;
-	name_ent_t		*p;
+	int		i;
+	struct name_ent	*ent;
 
 	for (i = 0; i < NAME_TABLE_SIZE; i++) {
-		while (nametable[i]) {
-			p = nametable[i];
-			nametable[i] = p->next;
-			free(p);
+		while ((ent = nametable[i])) {
+			nametable[i] = ent->next;
+			free(ent);
 		}
 	}
 }
 
+/*
+ * See if the given name is already in the name table.  If so,
+ * return a pointer to its entry, otherwise return a null pointer.
+ */
+static struct name_ent *
+nametable_find(xfs_dahash_t hash, int namelen, uchar_t *name)
+{
+	struct name_ent	*ent;
+
+	for (ent = nametable[hash % NAME_TABLE_SIZE]; ent; ent = ent->next) {
+		if (ent->hash == hash && ent->namelen == namelen &&
+				!memcmp(ent->name, name, namelen))
+			return ent;
+	}
+	return NULL;
+}
+
+/*
+ * Add the given name to the name table.  Returns a pointer to the
+ * name's new entry, or a null pointer if an error occurs.
+ */
+static struct name_ent *
+nametable_add(xfs_dahash_t hash, int namelen, uchar_t *name)
+{
+	struct name_ent	*ent;
+
+	ent = malloc(sizeof *ent + namelen);
+	if (!ent)
+		return NULL;
+
+	ent->namelen = namelen;
+	memcpy(ent->name, name, namelen);
+	ent->hash = hash;
+	ent->next = nametable[hash % NAME_TABLE_SIZE];
+
+	nametable[hash % NAME_TABLE_SIZE] = ent;
+
+	return ent;
+}
 
 #define is_invalid_char(c)	((c) == '/' || (c) == '\0')
 #define rol32(x,y)		(((x) << (y)) | ((x) >> (32 - (y))))
@@ -369,48 +408,440 @@ clear_nametable(void)
 static inline uchar_t
 random_filename_char(void)
 {
-	uchar_t			c;
+	static uchar_t filename_alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+						"abcdefghijklmnopqrstuvwxyz"
+						"0123456789-_";
 
-	do {
-		c = random() % 127 + 1;
-	} while (c == '/');
-	return c;
+	return filename_alphabet[random() % (sizeof filename_alphabet - 1)];
 }
 
+#define	ORPHANAGE	"lost+found"
+#define	ORPHANAGE_LEN	(sizeof (ORPHANAGE) - 1)
+
+static inline int
+is_orphanage_dir(
+	struct xfs_mount	*mp,
+	xfs_ino_t		dir_ino,
+	size_t			name_len,
+	uchar_t			*name)
+{
+	return dir_ino == mp->m_sb.sb_rootino &&
+			name_len == ORPHANAGE_LEN &&
+			!memcmp(name, ORPHANAGE, ORPHANAGE_LEN);
+}
+
+/*
+ * Determine whether a name is one we shouldn't obfuscate because
+ * it's an orphan (or the "lost+found" directory itself).  Note
+ * "cur_ino" is the inode for the directory currently being
+ * processed.
+ *
+ * Returns 1 if the name should NOT be obfuscated or 0 otherwise.
+ */
 static int
-is_special_dirent(
+in_lost_found(
 	xfs_ino_t		ino,
 	int			namelen,
 	uchar_t			*name)
 {
 	static xfs_ino_t	orphanage_ino = 0;
-	char			s[32];
+	char			s[24];	/* 21 is enough (64 bits in decimal) */
 	int			slen;
 
-	/*
-	 * due to the XFS name hashing algorithm, we cannot obfuscate
-	 * names with 4 chars or less.
-	 */
-	if (namelen <= 4)
+	/* Record the "lost+found" inode if we haven't done so already */
+
+	ASSERT(ino != 0);
+	if (!orphanage_ino && is_orphanage_dir(mp, cur_ino, namelen, name))
+		orphanage_ino = ino;
+
+	/* We don't obfuscate the "lost+found" directory itself */
+
+	if (ino == orphanage_ino)
 		return 1;
 
-	if (ino == 0)
+	/* Most files aren't in "lost+found" at all */
+
+	if (cur_ino != orphanage_ino)
 		return 0;
 
 	/*
-	 * don't obfuscate lost+found nor any inodes within lost+found with
-	 * the inode number
+	 * Within "lost+found", we don't obfuscate any file whose
+	 * name is the same as its inode number.  Any others are
+	 * stray files and can be obfuscated.
 	 */
-	if (cur_ino == mp->m_sb.sb_rootino && namelen == 10 &&
-			memcmp(name, "lost+found", 10) == 0) {
-		orphanage_ino = ino;
-		return 1;
+	slen = snprintf(s, sizeof (s), "%llu", (unsigned long long) ino);
+
+	return slen == namelen && !memcmp(name, s, namelen);
+}
+
+/*
+ * Given a name and its hash value, massage the name in such a way
+ * that the result is another name of equal length which shares the
+ * same hash value.
+ */
+static void
+obfuscate_name(
+	xfs_dahash_t	hash,
+	size_t		name_len,
+	uchar_t		*name)
+{
+	uchar_t		*newp = name;
+	int		i;
+	xfs_dahash_t	new_hash = 0;
+	uchar_t		*first;
+	uchar_t		high_bit;
+	int		shift;
+
+	/*
+	 * Our obfuscation algorithm requires at least 5-character
+	 * names, so don't bother if the name is too short.  We
+	 * work backward from a hash value to determine the last
+	 * five bytes in a name required to produce a new name
+	 * with the same hash.
+	 */
+	if (name_len < 5)
+		return;
+
+	/*
+	 * The beginning of the obfuscated name can be pretty much
+	 * anything, so fill it in with random characters.
+	 * Accumulate its new hash value as we go.
+	 */
+	for (i = 0; i < name_len - 5; i++) {
+		*newp = random_filename_char();
+		new_hash = *newp ^ rol32(new_hash, 7);
+		newp++;
 	}
-	if (cur_ino != orphanage_ino)
+
+	/*
+	 * Compute which five bytes need to be used at the end of
+	 * the name so the hash of the obfuscated name is the same
+	 * as the hash of the original.  If any result in an invalid
+	 * character, flip a bit and arrange for a corresponding bit
+	 * in a neighboring byte to be flipped as well.  For the
+	 * last byte, the "neighbor" to change is the first byte
+	 * we're computing here.
+	 */
+	new_hash = rol32(new_hash, 3) ^ hash;
+
+	first = newp;
+	high_bit = 0;
+	for (shift = 28; shift >= 0; shift -= 7) {
+		*newp = (new_hash >> shift & 0x7f) ^ high_bit;
+		if (is_invalid_char(*newp)) {
+			*newp ^= 1;
+			high_bit = 0x80;
+		} else
+			high_bit = 0;
+		ASSERT(!is_invalid_char(*newp));
+		newp++;
+	}
+
+	/*
+	 * If we flipped a bit on the last byte, we need to fix up
+	 * the matching bit in the first byte.  The result will
+	 * be a valid character, because we know that first byte
+	 * has 0's in its upper four bits (it was produced by a
+	 * 28-bit right-shift of a 32-bit unsigned value).
+	 */
+	if (high_bit) {
+		*first ^= 0x10;
+		ASSERT(!is_invalid_char(*first));
+	}
+	ASSERT(libxfs_da_hashname(name, name_len) == hash);
+}
+
+/*
+ * Flip a bit in each of two bytes at the end of the given name.
+ * This is used in generating a series of alternate names to be used
+ * in the event a duplicate is found.
+ *
+ * The bits flipped are selected such that they both affect the same
+ * bit in the name's computed hash value, so flipping them both will
+ * preserve the hash.
+ *
+ * The following diagram aims to show the portion of a computed
+ * hash that a given byte of a name affects.
+ *
+ *	   31    28      24    21	     14		  8 7       3     0
+ *	   +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ * hash:   | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
+ *	   +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ *	  last-4 ->|	       |<-- last-2 --->|	   |<--- last ---->|
+ *		 |<-- last-3 --->|	     |<-- last-1 --->|     |<- last-4
+ *			 |<-- last-7 --->|	     |<-- last-5 --->|
+ *	   |<-- last-8 --->|	       |<-- last-6 --->|
+ *			. . . and so on
+ *
+ * The last byte of the name directly affects the low-order byte of
+ * the hash.  The next-to-last affects bits 7-14, the next one back
+ * affects bits 14-21, and so on.  The effect wraps around when it
+ * goes beyond the top of the hash (as happens for byte last-4).
+ *
+ * Bits that are flipped together "overlap" on the hash value.  As
+ * an example of overlap, the last two bytes both affect bit 7 in
+ * the hash.  That pair of bytes (and their overlapping bits) can be
+ * used for this "flip bit" operation (it's the first pair tried,
+ * actually).
+ *
+ * A table defines overlapping pairs--the bytes involved and bits
+ * within them--that can be used this way.  The byte offset is
+ * relative to a starting point within the name, which will be set
+ * to affect the bytes at the end of the name.  The function is
+ * called with a "bitseq" value which indicates which bit flip is
+ * desired, and this translates directly into selecting which entry
+ * in the bit_to_flip[] table to apply.
+ *
+ * The function returns 1 if the operation was successful.  It
+ * returns 0 if the result produced a character that's not valid in
+ * a name (either '/' or a '\0').  Finally, it returns -1 if the bit
+ * sequence number is beyond what is supported for a name of this
+ * length.
+ *
+ * Discussion
+ * ----------
+ * (Also see the discussion above find_alternate(), below.)
+ *
+ * In order to make this function work for any length name, the
+ * table is ordered by increasing byte offset, so that the earliest
+ * entries can apply to the shortest strings.  This way all names
+ * are done consistently.
+ *
+ * When bit flips occur, they can convert printable characters
+ * into non-printable ones.  In an effort to reduce the impact of
+ * this, the first bit flips are chosen to affect bytes the end of
+ * the name (and furthermore, toward the low bits of a byte).  Those
+ * bytes are often non-printable anyway because of the way they are
+ * initially selected by obfuscate_name()).  This is accomplished,
+ * using later table entries first.
+ *
+ * Each row in the table doubles the number of alternates that
+ * can be generated.  A two-byte name is limited to using only
+ * the first row, so it's possible to generate two alternates
+ * (the original name, plus the alternate produced by flipping
+ * the one pair of bits).  In a 5-byte name, the effect of the
+ * first byte overlaps the last by 4 its, and there are 8 bits
+ * to flip, allowing for 256 possible alternates.
+ *
+ * Short names (less than 5 bytes) are never even obfuscated, so for
+ * such names the relatively small number of alternates should never
+ * really be a problem.
+ *
+ * Long names (more than 6 bytes, say) are not likely to exhaust
+ * the number of available alternates.  In fact, the table could
+ * probably have stopped at 8 entries, on the assumption that 256
+ * alternates should be enough for most any situation.  The entries
+ * beyond those are present mostly for demonstration of how it could
+ * be populated with more entries, should it ever be necessary to do
+ * so.
+ */
+static int
+flip_bit(
+	size_t		name_len,
+	uchar_t		*name,
+	uint32_t	bitseq)
+{
+	int	index;
+	size_t	offset;
+	uchar_t	*p0, *p1;
+	uchar_t	m0, m1;
+	struct {
+	    int		byte;	/* Offset from start within name */
+	    uchar_t	bit;	/* Bit within that byte */
+	} bit_to_flip[][2] = {	/* Sorted by second entry's byte */
+	    { { 0, 0 }, { 1, 7 } },	/* Each row defines a pair */
+	    { { 1, 0 }, { 2, 7 } },	/* of bytes and a bit within */
+	    { { 2, 0 }, { 3, 7 } },	/* each byte.  Each bit in */
+	    { { 0, 4 }, { 4, 0 } },	/* a pair affects the same */
+	    { { 0, 5 }, { 4, 1 } },	/* bit in the hash, so flipping */
+	    { { 0, 6 }, { 4, 2 } },	/* both will change the name */
+	    { { 0, 7 }, { 4, 3 } },	/* while preserving the hash. */
+	    { { 3, 0 }, { 4, 7 } },
+	    { { 0, 0 }, { 5, 3 } },	/* The first entry's byte offset */
+	    { { 0, 1 }, { 5, 4 } },	/* must be less than the second. */
+	    { { 0, 2 }, { 5, 5 } },
+	    { { 0, 3 }, { 5, 6 } },	/* The table can be extended to */
+	    { { 0, 4 }, { 5, 7 } },	/* an arbitrary number of entries */
+	    { { 4, 0 }, { 5, 7 } },	/* but there's not much point. */
+		/* . . . */
+	};
+
+	/* Find the first entry *not* usable for name of this length */
+
+	for (index = 0; index < ARRAY_SIZE(bit_to_flip); index++)
+		if (bit_to_flip[index][1].byte >= name_len)
+			break;
+
+	/*
+	 * Back up to the last usable entry.  If that number is
+	 * smaller than the bit sequence number, inform the caller
+	 * that nothing this large (or larger) will work.
+	 */
+	if (bitseq > --index)
+		return -1;
+
+	/*
+	 * We will be switching bits at the end of name, with a
+	 * preference for affecting the last bytes first.  Compute
+	 * where in the name we'll start applying the changes.
+	 */
+	offset = name_len - (bit_to_flip[index][1].byte + 1);
+	index -= bitseq;	/* Use later table entries first */
+
+	p0 = name + offset + bit_to_flip[index][0].byte;
+	p1 = name + offset + bit_to_flip[index][1].byte;
+	m0 = 1 << bit_to_flip[index][0].bit;
+	m1 = 1 << bit_to_flip[index][1].bit;
+
+	/* Only change the bytes if it produces valid characters */
+
+	if (is_invalid_char(*p0 ^ m0) || is_invalid_char(*p1 ^ m1))
 		return 0;
 
-	slen = sprintf(s, "%lld", (long long)ino);
-	return (slen == namelen && memcmp(name, s, namelen) == 0);
+	*p0 ^= m0;
+	*p1 ^= m1;
+
+	return 1;
+}
+
+/*
+ * This function generates a well-defined sequence of "alternate"
+ * names for a given name.  An alternate is a name having the same
+ * length and same hash value as the original name.  This is needed
+ * because the algorithm produces only one obfuscated name to use
+ * for a given original name, and it's possible that result matches
+ * a name already seen.  This function checks for this, and if it
+ * occurs, finds another suitable obfuscated name to use.
+ *
+ * Each bit in the binary representation of the sequence number is
+ * used to select one possible "bit flip" operation to perform on
+ * the name.  So for example:
+ *    seq = 0:	selects no bits to flip
+ *    seq = 1:	selects the 0th bit to flip
+ *    seq = 2:	selects the 1st bit to flip
+ *    seq = 3:	selects the 0th and 1st bit to flip
+ *    ... and so on.
+ *
+ * The flip_bit() function takes care of the details of the bit
+ * flipping within the name.  Note that the "1st bit" in this
+ * context is a bit sequence number; i.e. it doesn't necessarily
+ * mean bit 0x02 will be changed.
+ *
+ * If a valid name (one that contains no '/' or '\0' characters) is
+ * produced by this process for the given sequence number, this
+ * function returns 1.  If the result is not valid, it returns 0.
+ * Returns -1 if the sequence number is beyond the the maximum for
+ * names of the given length.
+ *
+ *
+ * Discussion
+ * ----------
+ * The number of alternates available for a given name is dependent
+ * on its length.  A "bit flip" involves inverting two bits in
+ * a name--the two bits being selected such that their values
+ * affect the name's hash value in the same way.  Alternates are
+ * thus generated by inverting the value of pairs of such
+ * "overlapping" bits in the original name.  Each byte after the
+ * first in a name adds at least one bit of overlap to work with.
+ * (See comments above flip_bit() for more discussion on this.)
+ *
+ * So the number of alternates is dependent on the number of such
+ * overlapping bits in a name.  If there are N bit overlaps, there
+ * 2^N alternates for that hash value.
+ *
+ * Here are the number of overlapping bits available for generating
+ * alternates for names of specific lengths:
+ *	1	0	(must have 2 bytes to have any overlap)
+ *	2	1	One bit overlaps--so 2 possible alternates
+ *	3	2	Two bits overlap--so 4 possible alternates
+ *	4	4	Three bits overlap, so 2^3 alternates
+ *	5	8	8 bits overlap (due to wrapping), 256 alternates
+ *	6	18	2^18 alternates
+ *	7	28	2^28 alternates
+ *	   ...
+ * It's clear that the number of alternates grows very quickly with
+ * the length of the name.  But note that the set of alternates
+ * includes invalid names.  And for certain (contrived) names, the
+ * number of valid names is a fairly small fraction of the total
+ * number of alternates.
+ *
+ * The main driver for this infrastructure for coming up with
+ * alternate names is really related to names 5 (or possibly 6)
+ * bytes in length.  5-byte obfuscated names contain no randomly-
+ * generated bytes in them, and the chance of an obfuscated name
+ * matching an already-seen name is too high to just ignore.  This
+ * methodical selection of alternates ensures we don't produce
+ * duplicate names unless we have exhausted our options.
+ */
+static int
+find_alternate(
+	size_t		name_len,
+	uchar_t		*name,
+	uint32_t	seq)
+{
+	uint32_t	bitseq = 0;
+	uint32_t	bits = seq;
+
+	if (!seq)
+		return 1;	/* alternate 0 is the original name */
+	if (name_len < 2)	/* Must have 2 bytes to flip */
+		return -1;
+
+	for (bitseq = 0; bits; bitseq++) {
+		uint32_t	mask = 1 << bitseq;
+		int		fb;
+
+		if (!(bits & mask))
+			continue;
+
+		fb = flip_bit(name_len, name, bitseq);
+		if (fb < 1)
+			return fb ? -1 : 0;
+		bits ^= mask;
+	}
+
+	return 1;
+}
+
+/*
+ * Look up the given name in the name table.  If it is already
+ * present, iterate through a well-defined sequence of alternate
+ * names and attempt to use an alternate name instead.
+ *
+ * Returns 1 if the (possibly modified) name is not present in the
+ * name table.  Returns 0 if the name and all possible alternates
+ * are already in the table.
+ */
+static int
+handle_duplicate_name(xfs_dahash_t hash, size_t name_len, uchar_t *name)
+{
+	uchar_t		new_name[name_len + 1];
+	uint32_t	seq = 1;
+
+	if (!nametable_find(hash, name_len, name))
+		return 1;	/* No duplicate */
+
+	/* Name is already in use.  Need to find an alternate. */
+
+	do {
+		int	found;
+
+		/* Only change incoming name if we find an alternate */
+		do {
+			memcpy(new_name, name, name_len);
+			found = find_alternate(name_len, new_name, seq++);
+			if (found < 0)
+				return 0;	/* No more to check */
+		} while (!found);
+	} while (nametable_find(hash, name_len, new_name));
+
+	/*
+	 * The alternate wasn't in the table already.  Pass it back
+	 * to the caller.
+	 */
+	memcpy(name, new_name, name_len);
+
+	return 1;
 }
 
 static void
@@ -420,77 +851,51 @@ generate_obfuscated_name(
 	uchar_t			*name)
 {
 	xfs_dahash_t		hash;
-	name_ent_t		*p;
-	int			i;
-	int			dup;
-	xfs_dahash_t		newhash;
-	uchar_t			newname[NAME_MAX];
 
-	if (is_special_dirent(ino, namelen, name))
+	/*
+	 * We don't obfuscate "lost+found" or any orphan files
+	 * therein.  When the name table is used for extended
+	 * attributes, the inode number provided is 0, in which
+	 * case we don't need to make this check.
+	 */
+	if (ino && in_lost_found(ino, namelen, name))
 		return;
 
-	hash = libxfs_da_hashname(name, namelen);
-
-	/* create a random name with the same hash value */
-
-	do {
-		dup = 0;
-		newname[0] = '/';
-
-		for (;;) {
-			/* if the first char is a "/", preserve it */
-			i = (name[0] == '/');
-
-			for (newhash = 0; i < namelen - 5; i++) {
-				newname[i] = random_filename_char();
-				newhash = newname[i] ^ rol32(newhash, 7);
-			}
-			newhash = rol32(newhash, 3) ^ hash;
-			if (name[0] != '/' || namelen > 5) {
-				newname[namelen - 5] = (newhash >> 28) |
-						(random_filename_char() & 0xf0);
-				if (is_invalid_char(newname[namelen - 5]))
-					continue;
-			}
-			newname[namelen - 4] = (newhash >> 21) & 0x7f;
-			if (is_invalid_char(newname[namelen - 4]))
-				continue;
-			newname[namelen - 3] = (newhash >> 14) & 0x7f;
-			if (is_invalid_char(newname[namelen - 3]))
-				continue;
-			newname[namelen - 2] = (newhash >> 7) & 0x7f;
-			if (is_invalid_char(newname[namelen - 2]))
-				continue;
-			newname[namelen - 1] = ((newhash >> 0) ^
-					(newname[namelen - 5] >> 4)) & 0x7f;
-			if (is_invalid_char(newname[namelen - 1]))
-				continue;
-			break;
-		}
-
-		ASSERT(libxfs_da_hashname(newname, namelen) == hash);
+	/*
+	 * If the name starts with a slash, just skip over it.  It
+	 * isn't included in the hash and we don't record it in the
+	 * name table.  Note that the namelen value passed in does
+	 * not count the leading slash (if one is present).
+	 */
+	if (*name == '/')
+		name++;
 
-		for (p = nametable[hash % NAME_TABLE_SIZE]; p; p = p->next) {
-			if (p->hash == hash && p->namelen == namelen &&
-					memcmp(p->name, newname, namelen) == 0){
-				dup = 1;
-				break;
-			}
-		}
-	} while (dup);
+	/* Obfuscate the name (if possible) */
 
-	memcpy(name, newname, namelen);
+	hash = libxfs_da_hashname(name, namelen);
+	obfuscate_name(hash, namelen, name);
 
-	p = malloc(sizeof(name_ent_t) + namelen);
-	if (p == NULL)
+	/*
+	 * Make sure the name is not something already seen.  If we
+	 * fail to find a suitable alternate, we're dealing with a
+	 * very pathological situation, and we may end up creating
+	 * a duplicate name in the metadump, so issue a warning.
+	 */
+	if (!handle_duplicate_name(hash, namelen, name)) {
+		print_warning("duplicate name for inode %llu "
+				"in dir inode %llu\n",
+			(unsigned long long) ino,
+			(unsigned long long) cur_ino);
 		return;
+	}
 
-	p->next = nametable[hash % NAME_TABLE_SIZE];
-	p->hash = hash;
-	p->namelen = namelen;
-	memcpy(p->name, name, namelen);
+	/* Create an entry for the new name in the name table. */
 
-	nametable[hash % NAME_TABLE_SIZE] = p;
+	if (!nametable_add(hash, namelen, name))
+		print_warning("unable to record name for inode %llu "
+				"in dir inode %llu\n",
+			(unsigned long long) ino,
+			(unsigned long long) cur_ino);
 }
 
 static void
@@ -1193,7 +1598,7 @@ process_inode(
 			break;
 		default: ;
 	}
-	clear_nametable();
+	nametable_clear();
 
 	/* copy extended attributes if they exist and forkoff is valid */
 	if (success && XFS_DFORK_DSIZE(dip, mp) < XFS_LITINO(mp)) {
@@ -1212,7 +1617,7 @@ process_inode(
 				success = process_btinode(dip, TYP_ATTR);
 				break;
 		}
-		clear_nametable();
+		nametable_clear();
 	}
 	return success;
 }
@@ -1615,12 +2020,6 @@ metadump_f(
 	metablock->mb_blocklog = BBSHIFT;
 	metablock->mb_magic = cpu_to_be32(XFS_MD_MAGIC);
 
-	if (!create_nametable()) {
-		print_warning("memory allocation failure");
-		free(metablock);
-		return 0;
-	}
-
 	block_index = (__be64 *)((char *)metablock + sizeof(xfs_metablock_t));
 	block_buffer = (char *)metablock + BBSIZE;
 	num_indicies = (BBSIZE - sizeof(xfs_metablock_t)) / sizeof(__be64);
@@ -1630,7 +2029,6 @@ metadump_f(
 	if (strcmp(argv[optind], "-") == 0) {
 		if (isatty(fileno(stdout))) {
 			print_warning("cannot write to a terminal");
-			free(nametable);
 			free(metablock);
 			return 0;
 		}
@@ -1639,7 +2037,6 @@ metadump_f(
 		outf = fopen(argv[optind], "wb");
 		if (outf == NULL) {
 			print_warning("cannot create dump file");
-			free(nametable);
 			free(metablock);
 			return 0;
 		}
@@ -1676,7 +2073,6 @@ metadump_f(
 	while (iocur_sp > start_iocur_sp)
 		pop_cur();
 
-	free(nametable);
 	free(metablock);
 
 	return 0;
diff --git a/include/libxfs.h b/include/libxfs.h
index e7199c7..6f4d17c 100644
--- a/include/libxfs.h
+++ b/include/libxfs.h
@@ -55,6 +55,9 @@
 #include <xfs/xfs_btree_trace.h>
 #include <xfs/xfs_bmap.h>
 
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
 
 #ifndef XFS_SUPER_MAGIC
 #define XFS_SUPER_MAGIC 0x58465342
