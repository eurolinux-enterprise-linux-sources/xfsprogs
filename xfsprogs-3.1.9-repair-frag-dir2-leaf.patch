commit 9fe1cc862159b50651baa68a6b60ae0819d4f871
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Tue Jun 5 13:25:57 2012 -0500

    xfs_repair: handle fragmented multiblock dir2 in process_leaf_node_dir2()
    
    process_leaf_node_dir2() had the following loop:
    
    	while ((dbno = blkmap_next_off(blkmap, ndbno, &t)) < mp->m_dirleafblk) {
    		...
    		ndbno = dbno + mp->m_dirblkfsbs - 1;
    		...
    	}
    
    which does not account for fragmented multiblock dir2.
    
    ndbno was blindly being advanced by m_dirblkfsbs, but then
    blkmap_next_off() would return the logical block of the next
    mapped extent in blkmap, which may be within the current
    (fragmented) dir2 multi-block, not the next multi-block,
    because the extent index t hadn't been advanced.
    
    Fix this by calling blkmap_next_off() until ndbno has advanced
    into the next multiblock dir2 block, thereby keeping
    the extent index t straight while properly advancing
    ndbno.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Reviewed-by: Ben Myers <bpm@sgi.com>

Index: xfsprogs-3.1.1/repair/dir2.c
===================================================================
--- xfsprogs-3.1.1.orig/repair/dir2.c
+++ xfsprogs-3.1.1/repair/dir2.c
@@ -1997,7 +1997,11 @@ process_leaf_node_dir2(
 	ndbno = NULLDFILOFF;
 	while ((dbno = blkmap_next_off(blkmap, ndbno, &t)) < mp->m_dirleafblk) {
 		nex = blkmap_getn(blkmap, dbno, mp->m_dirblkfsbs, &bmp, &lbmp);
-		ndbno = dbno + mp->m_dirblkfsbs - 1;
+		/* Advance through map to last dfs block in this dir block */
+		ndbno = dbno;
+		while (ndbno < dbno + mp->m_dirblkfsbs - 1) {
+			ndbno = blkmap_next_off(blkmap, ndbno, &t);
+		}
 		if (nex == 0) {
 			do_warn(_("block %llu for directory inode %llu is "
 				  "missing\n"),
