commit 8e78288a3a994534a320f9699c91572f7c859b8c
Author: Dave Chinner <dchinner@redhat.com>
Date:   Thu May 9 11:20:13 2013 -0500

    xfs_logprint: fix continuation transactions
    
    As demonstrated by xfs/295, continuation transactions cause of
    problems for xfs_logprint. The failure demonstrated by the test is
    that the buffer log format structures are variable sized on disk -
    the dirty bitmap is sized according to the buffer length, not fixed
    to the length of the maximum supported buffer size.
    
    xfs_logprint assumes that the buf log format reocrds are of fixed
    size, and so when a short buffer is found it fails to handle it
    properly and treats it like a continuation record.  This causses the
    opheader pointer to be incremented incorrectly and then logprint
    wanders off into a dark corner and gets eaten by a grue.
    
    While fixing this, make the xlog_print_record code that does the
    transaction opheader walking a little easier to read and stop it
    from outputting binary data direct to the console by converting the
    no-data-print case to use a hex dumping loop.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Mark Tinguely <tinguely@sgi.com>
    Signed-off-by: Rich Johnston <rjohnston@sgi.com>

Index: xfsprogs-3.1.1/logprint/log_misc.c
===================================================================
--- xfsprogs-3.1.1.orig/logprint/log_misc.c
+++ xfsprogs-3.1.1/logprint/log_misc.c
@@ -269,7 +269,13 @@ xlog_print_trans_buffer(xfs_caddr_t *ptr
     blen = f->blf_len;
     map_size = f->blf_map_size;
     flags = f->blf_flags;
-    struct_size = sizeof(xfs_buf_log_format_t);
+
+    /*
+     * size of the format header is dependent on the size of the bitmap, not
+     * the size of the in-memory structure. Hence the slightly obtuse
+     * calculation.
+     */
+    struct_size = offsetof(xfs_buf_log_format_t, blf_map_size) + map_size;
 
     if (len >= struct_size) {
 	ASSERT((len - sizeof(struct_size)) % sizeof(int) == 0);
@@ -931,22 +937,28 @@ xlog_print_record(int			  fd,
 	continued = (XLOG_SET(op_head->oh_flags, XLOG_WAS_CONT_TRANS) ||
 		     XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS));
 
-	/* print transaction data */
-	if (print_no_data ||
-	    (continued && be32_to_cpu(op_head->oh_len) == 0)) {
+	if (continued && be32_to_cpu(op_head->oh_len) == 0)
+		continue;
+
+	if (print_no_data) {
 	    for (n = 0; n < be32_to_cpu(op_head->oh_len); n++) {
-		printf("%c", *ptr);
+		printf("0x%02x ", (unsigned int)*ptr);
+		if (n % 16 == 15)
+			printf("\n");
 		ptr++;
 	    }
 	    printf("\n");
 	    continue;
 	}
+
+	/* print transaction data */
 	if (xlog_print_find_tid(be32_to_cpu(op_head->oh_tid),
 				op_head->oh_flags & XLOG_WAS_CONT_TRANS)) {
 	    printf(_("Left over region from split log item\n"));
 	    ptr += be32_to_cpu(op_head->oh_len);
 	    continue;
 	}
+
 	if (be32_to_cpu(op_head->oh_len) != 0) {
 	    if (*(uint *)ptr == XFS_TRANS_HEADER_MAGIC) {
 		skip = xlog_print_trans_header(&ptr,
