commit dda41291cb69517f6011f3773999ece3c717318b
Author: Eric Sandeen <sandeen@sandeen.net>
Date:   Wed Jan 2 17:02:17 2013 -0600

    xfs_logprint: Handle multiply-logged inode fields
    
    As xlog_print_trans_inode() stands today, it will error
    out if more than one flag is set on f->ilf_fields:
    
    	xlog_print_trans_inode: illegal inode type
    
    but this is a perfectly valid case, to have i.e. a data and
    an attr flag set.
    
    Following is a pretty big reworking of the function to
    handle more than one field type set, mostly following
    xlog_recover_inode_pass2() for logic.
    
    I've tested this by a simple test such as creating one
    file on an selinux box, so that data+attr is set, and
    logprinting; I've also tested by running logprint after
    subsequent xfstest runs (although we hit other bugs that
    way).
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Reviewed-by: Ben Myers <bpm@sgi.com>
    Signed-off-by: Ben Myers <bpm@sgi.com>

Index: xfsprogs-3.1.1/logprint/log_misc.c
===================================================================
--- xfsprogs-3.1.1.orig/logprint/log_misc.c
+++ xfsprogs-3.1.1/logprint/log_misc.c
@@ -650,97 +650,76 @@ xlog_print_trans_inode(xfs_caddr_t *ptr,
 
     /* does anything come next */
     op_head = (xlog_op_header_t *)*ptr;
-    switch (f->ilf_fields & XFS_ILOG_NONCORE) {
-	case XFS_ILOG_DEXT: {
-	    ASSERT(f->ilf_size == 3);
-	    (*i)++;
-	    xlog_print_op_header(op_head, *i, ptr);
-	    printf(_("EXTENTS inode data\n"));
-	    *ptr += be32_to_cpu(op_head->oh_len);
-	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS))  {
-		return 1;
-	    }
-	    break;
-	}
-	case XFS_ILOG_DBROOT: {
-	    ASSERT(f->ilf_size == 3);
-	    (*i)++;
-	    xlog_print_op_header(op_head, *i, ptr);
-	    printf(_("BTREE inode data\n"));
-	    *ptr += be32_to_cpu(op_head->oh_len);
-	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS))  {
-		return 1;
-	    }
-	    break;
-	}
-	case XFS_ILOG_DDATA: {
-	    ASSERT(f->ilf_size == 3);
-	    (*i)++;
-	    xlog_print_op_header(op_head, *i, ptr);
-	    printf(_("LOCAL inode data\n"));
-	    if (mode == S_IFDIR) {
-		xlog_print_dir_sf((xfs_dir_shortform_t*)*ptr, size);
-	    }
-	    *ptr += be32_to_cpu(op_head->oh_len);
-	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS)) {
-		return 1;
-	    }
-	    break;
-	}
-	case XFS_ILOG_AEXT: {
-	    ASSERT(f->ilf_size == 3);
+
+    switch (f->ilf_fields & (XFS_ILOG_DEV | XFS_ILOG_UUID)) {
+    case XFS_ILOG_DEV:
+	printf(_("DEV inode: no extra region\n"));
+	break;
+    case XFS_ILOG_UUID:
+	printf(_("UUID inode: no extra region\n"));
+	break;
+    }
+
+    /* Only the inode core is logged */
+    if (f->ilf_size == 2)
+	return 0;
+
+    ASSERT(f->ilf_size <= 4);
+    ASSERT((f->ilf_size == 3) || (f->ilf_fields & XFS_ILOG_AFORK));
+
+    if (f->ilf_fields & XFS_ILOG_DFORK) {
 	    (*i)++;
 	    xlog_print_op_header(op_head, *i, ptr);
-	    printf(_("EXTENTS inode attr\n"));
-	    *ptr += be32_to_cpu(op_head->oh_len);
-	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS))  {
-		return 1;
+
+	    switch (f->ilf_fields & XFS_ILOG_DFORK) {
+	    case XFS_ILOG_DEXT:
+		printf(_("EXTENTS inode data\n"));
+		break;
+	    case XFS_ILOG_DBROOT:
+		printf(_("BTREE inode data\n"));
+		break;
+	    case XFS_ILOG_DDATA:
+		printf(_("LOCAL inode data\n"));
+		if (mode == S_IFDIR)
+		    xlog_print_dir_sf((xfs_dir_shortform_t*)*ptr, size);
+		break;
+	    default:
+		ASSERT((f->ilf_fields & XFS_ILOG_DFORK) == 0);
+		break;
 	    }
-	    break;
-	}
-	case XFS_ILOG_ABROOT: {
-	    ASSERT(f->ilf_size == 3);
-	    (*i)++;
-	    xlog_print_op_header(op_head, *i, ptr);
-	    printf(_("BTREE inode attr\n"));
+
 	    *ptr += be32_to_cpu(op_head->oh_len);
-	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS))  {
+	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS))
 		return 1;
-	    }
-	    break;
-	}
-	case XFS_ILOG_ADATA: {
-	    ASSERT(f->ilf_size == 3);
+	    op_head = (xlog_op_header_t *)*ptr;
+    }
+
+    if (f->ilf_fields & XFS_ILOG_AFORK) {
 	    (*i)++;
 	    xlog_print_op_header(op_head, *i, ptr);
-	    printf(_("LOCAL inode attr\n"));
-	    if (mode == S_IFDIR) {
-		xlog_print_dir_sf((xfs_dir_shortform_t*)*ptr, size);
+
+	    switch (f->ilf_fields & XFS_ILOG_AFORK) {
+	    case XFS_ILOG_AEXT:
+		printf(_("EXTENTS attr data\n"));
+		break;
+	    case XFS_ILOG_ABROOT:
+		printf(_("BTREE attr data\n"));
+		break;
+	    case XFS_ILOG_ADATA:
+		printf(_("LOCAL attr data\n"));
+		if (mode == S_IFDIR)
+		    xlog_print_dir_sf((xfs_dir_shortform_t*)*ptr, size);
+		break;
+	    default:
+		ASSERT((f->ilf_fields & XFS_ILOG_AFORK) == 0);
+		break;
 	    }
 	    *ptr += be32_to_cpu(op_head->oh_len);
-	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS)) {
+	    if (XLOG_SET(op_head->oh_flags, XLOG_CONTINUE_TRANS))
 		return 1;
-	    }
-	    break;
-	}
-	case XFS_ILOG_DEV: {
-	    ASSERT(f->ilf_size == 2);
-	    printf(_("DEV inode: no extra region\n"));
-	    break;
-	}
-	case XFS_ILOG_UUID: {
-	    ASSERT(f->ilf_size == 2);
-	    printf(_("UUID inode: no extra region\n"));
-	    break;
-	}
-	case 0: {
-	    ASSERT(f->ilf_size == 2);
-	    break;
-	}
-	default: {
-	    xlog_panic(_("xlog_print_trans_inode: illegal inode type"));
-	}
+	    op_head = (xlog_op_header_t *)*ptr;
     }
+
     return 0;
 }	/* xlog_print_trans_inode */
 
